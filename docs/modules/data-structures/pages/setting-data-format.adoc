= Setting In-Memory Format of Map Entries
:description: By default, Hazelcast stores map entries in binary (serialized) format in on-heap memory. This option is useful if you mainly read and write data to a map. However, for other use cases it may be more efficient to store entries in their object form or even in off-heap memory.
of local processing, such as entry processor and queries.

[[setting-in-memory-format]]

{description}

To configure how map data will be stored in the memory, specify the `in-memory-format` element in the configuration:

* `BINARY` (default): The data (both the key and value) is stored in serialized
binary format. You can use this option if you mostly perform regular map
operations, such as `put` and `get`.
* `OBJECT`: The data is stored in deserialized form. This configuration is
good for maps where xref:computing:entry-processor.adoc[entry processing] and xref:query:how-distributed-query-works.adoc[queries] form the majority of all
operations and the objects are complex, making the serialization cost comparatively
high. By storing objects, entry processing does not contain the deserialization
cost. Note that when you use `OBJECT` as the in-memory format, the key is still
stored in binary format and the value is stored in object format.
* `NATIVE`: ([navy]*Hazelcast IMDG Enterprise HD*) This format behaves the same as
BINARY, however, instead of heap memory, key and value are stored in the off-heap
memory.

Regular operations like `get` rely on the object instance. When the `OBJECT` format
is used and a `get` is performed, the map does not return the stored instance,
but creates a clone. Therefore, this whole `get` operation first includes a
serialization on the member owning the instance and then a deserialization on
the member calling the instance. When the `BINARY` format is used, only a
deserialization is required; `BINARY` is faster.

Similarly, a `put` operation is faster when the `BINARY` format is used. If the
format was `OBJECT`, the map would create a clone of the instance, and there would
first be a serialization and then a deserialization. When BINARY is used, only a
deserialization is needed.

NOTE: If a value is stored in `OBJECT` format, a change on a returned value does not
affect the stored instance. In this case, the returned instance is not the actual one
but a clone. Therefore, changes made on an object after it is returned will not reflect
on the actual stored data. Similarly, when a value is written to a map and the value is
stored in `OBJECT` format, it will be a copy of the `put` value. Therefore, changes made
on the object after it is stored will not reflect on the stored data.

[[using-high-density-memory-store-with-map]]
== Using High-Density Memory Store with Map

[navy]*Hazelcast IMDG Enterprise HD*

Hazelcast instances are Java programs. In case of `BINARY` and `OBJECT` in-memory
formats, Hazelcast stores your distributed data into the heap of its server instances.
Java heap is subject to garbage collection (GC). In case of larger heaps, garbage
collection might cause your application to pause for tens of seconds (even minutes
for really large heaps), badly affecting your application performance and response times.

As the data gets bigger, you either run the application with larger heap, which would
result in longer GC pauses or run multiple instances with smaller heap which can turn
into an operational nightmare if the number of such instances becomes very high.

To overcome this challenge, Hazelcast offers High-Density Memory Store for your maps.
You can configure your map to use High-Density Memory Store by setting the in-memory
format to `NATIVE`. The following snippet is the declarative configuration example.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <map name="nativeMap">
        <in-memory-format>NATIVE</in-memory-format>
    </map>
    ...
</hazelcast>
----
--

YAML::
+
[source,yaml]
----
hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
----
====

Keep in mind that you should have already enabled the High-Density Memory Store
usage for your cluster. See the xref:storage:high-density-memory.adoc#configuring-high-density-memory-store[Configuring High-Density Memory Store section].

You can also benefit from the persistent memory technologies such as
Intel(R) Optane(TM) DC to be used by the High-Density Memory Store. See the
xref:storage:high-density-memory.adoc#using-persistent-memory[Using Persistent Memory section].

[[required-configuration-changes-when-using-native]]
=== Required Configuration Changes When Using NATIVE

Note that the eviction mechanism is different for `NATIVE` in-memory format.
The new eviction algorithm for map with High-Density Memory Store is similar
to that of JCache with High-Density Memory Store and is described xref:jcache:icache.adoc#eviction-algorithm[here].

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <map name="nativeMap">
        <in-memory-format>NATIVE</in-memory-format>
        <eviction-percentage>25</eviction-percentage> <--! NO IMPACT with NATIVE -->
    </map>
    ...
</hazelcast>
----
--

YAML::
+
[source,yaml]
----
hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
      eviction-percentage: 25 # NO IMPACT with NATIVE
----
====

* These IMap eviction policies for `size` cannot be used: `FREE_HEAP_PERCENTAGE`,
`FREE_HEAP_SIZE`, `USED_HEAP_PERCENTAGE`, `USED_HEAP_SIZE`.
* Near Cache eviction policy `ENTRY_COUNT` cannot be used for
`max-size-policy`.

NOTE: See the xref:storage:high-density-memory.adoc[High-Density Memory Store section]
for more information.