= Locking Maps
:description: Although maps are thread-safe, you may prefer to have manual control over which members have access to a map entry at a given time. Hazelcast offers two ways of locking map entries: pessimistic locking and optimistic locking.

{description}

Hazelcast uses and manages its own partition threads. Each partition is managed by a single thread, ensuring that write operations to a given partition are handled one at a time in first-in-first-out order. In other words, it is not possible for multiple simultaneous write attempts to any given map entry. In most cases, this operational model is sufficient in preventing race conditions. (For more on threading operations, refer to the xref:performance:threading-model.adoc[Threading Model]. )

However, in some circumstances, you may need manual control over access to map entries. Consider the following example:

[source,java]
----
include::{javasource}/dds/map/RacyUpdateMember.java[tag=racy]
----

If this code is run by more than one cluster member simultaneously, it can cause a race condition. You can solve this condition using either pessimistic or optimistic locking to manually ensure that the map entry cannot be overwritten until the locking operation is complete. 

[[pessimistic-locking]]
== Pessimistic Locking

Pessimistic locking locks the map entry until you are finished with it.

To perform pessimistic locking, use the map's `lock()` and `unlock()` methods.

[source,java]
----
include::{javasource}/dds/map/PessimisticUpdateMember.java[tag=pum]
----

The lock will automatically be collected by the garbage collector when the lock is released and no other waiting conditions exist on the lock.

The lock is reentrant, but it does not support fairness.

WARNING: In some cases, a client application connected to your cluster may cause the entries in a map to remain locked after the application has been restarted (which were already locked
before such a restart). This can be due to the reasons such as incomplete/incorrect client implementations. In these cases, you can unlock the entries, either from the thread which locked them
using the `IMap.unlock()` method, or check if the entry is locked using the `IMap.isLock()` method and then call `IMap.forceUnlock()`.

TIP: For the above case, as a workaround, you can also kill all the applications connected
to the cluster and use the Management Center's scripting functionality to clear the map and
release the locks (instead of using `IMap.forceUnlock()`). Keep in mind that the scripting
functionality is limited to working with maps that have primitive key types, e.g., string keys
and limited to relaying only a single string of output per member to the result panel in the Management Center.

Another way to solve the race issue is by acquiring a predictable `Lock`
object from Hazelcast. This way, every value in the map can be given a lock,
or you can create a stripe of locks.

[[optimistic-locking]]
== Optimistic Locking

In Hazelcast, you can apply the optimistic locking strategy with the
map's `replace()` method. This method compares values in object or data forms
depending on the in-memory format configuration. If the values are equal,
it replaces the old value with the new one. If you want to use your defined
`equals` method, `in-memory-format` should be `OBJECT`. Otherwise, Hazelcast
serializes objects to `BINARY` forms and compares them.

See the below example code.

NOTE: The below example code is intentionally broken.

[source,java]
----
include::{javasource}/dds/map/OptimisticMember.java[tag=om]
----

[[pessimistic-vs-optimistic-locking]]
== Pessimistic vs. Optimistic Locking

The locking strategy you choose depends on your locking requirements.

Optimistic locking is better for mostly read-only systems. It has a
performance boost over pessimistic locking.

Pessimistic locking is good if there are lots of updates on the same
key. It is more robust than optimistic locking from the perspective of data consistency.

In Hazelcast, use `IExecutorService` to submit a task to a key owner,
or to a member or members. This is the recommended way to perform task executions,
rather than using pessimistic or optimistic locking techniques. `IExecutorService`
has fewer network hops and less data over wire, and tasks are executed very near to the data.
See the xref:performance:data-affinity.adoc[Data Affinity section].

[[solving-the-aba-problem]]
== Solving the ABA Problem

The ABA problem occurs in environments when a shared resource is
open to change by multiple threads. Even if one thread sees the same value
for a particular key in consecutive reads, it does not mean that nothing
has changed between the reads. Another thread may change the value,
do work and change the value back, while the first thread thinks that nothing has changed.

To prevent these kind of problems, you can assign a version number and
check it before any write to be sure that nothing has changed between consecutive reads.
Although all the other fields are equal, the version field will prevent objects
from being seen as equal. This is the optimistic locking strategy; it is used in
environments that do not expect intensive concurrent changes on a specific key.

In Hazelcast, you can apply the <<optimistic-locking, optimistic locking>>
strategy with the map `replace` method.

[[lock-split-brain-protection-with-pessimistic-locking]]
== Lock Split-Brain Protection with Pessimistic Locking

Locks can be configured to check the number of currently present members
before applying a locking operation. If the check fails, the lock operation
fails with a `SplitBrainProtectionException` (see the xref:network-partitioning:split-brain-protection.adoc[Split-Brain Protection section]).
As pessimistic locking uses lock operations internally, it also uses the configured
lock split-brain protection. This means that you can configure a lock split-brain protection with the same name or a
pattern that matches the map name. Note that the split-brain protection for locking actions can be
different from the split-brain protection for other map actions.

The following actions check for lock split-brain protection before being applied:

* `IMap.lock(K)` and `IMap.lock(K, long, java.util.concurrent.TimeUnit)`
* `IMap.isLocked()`
* `IMap.tryLock(K)`, `IMap.tryLock(K, long, java.util.concurrent.TimeUnit)` and
`IMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)`
* `IMap.unlock()`
* `IMap.forceUnlock()`
* `MultiMap.lock(K)` and `MultiMap.lock(K, long, java.util.concurrent.TimeUnit)`
* `MultiMap.isLocked()`
* `MultiMap.tryLock(K)`, `MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit)`
and `MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)`
* `MultiMap.unlock()`
* `MultiMap.forceUnlock()`

An example of declarative configuration:

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <map name="myMap">
        <split-brain-protection-ref>map-actions-split-brain-protection</split-brain-protection-ref>
    </map>
    <lock name="myMap">
        <split-brain-protection-ref>map-lock-actions-split-brain-protection</split-brain-protection-ref>
    </lock>
    ...
</hazelcast>
----
--

YAML::
+
[source,yaml]
----
hazelcast:
  map:
    myMap:
      split-brain-protection-ref: map-actions-split-brain-protection
  lock:
    myMap:
      split-brain-protection-ref: map-lock-actions-split-brain-protection
----
====

Here the configured map uses the `map-lock-actions-split-brain-protection` for
map lock actions and the `map-actions-split-brain-protection` for other map actions.